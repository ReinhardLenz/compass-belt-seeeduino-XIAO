// Content from Compass.cpp
#include "Compass.h"

void Compass::quaternionToEuler(float qr, float qi, float qj, float qk, euler_t* ypr, bool degrees) {
    float sqr = sq(qr);
    float sqi = sq(qi);
    float sqj = sq(qj);
    float sqk = sq(qk);
    ypr->yaw = atan2(2.0 * (qi * qj + qk * qr), (sqi - sqj - sqk + sqr));
    ypr->pitch = asin(-2.0 * (qi * qk - qj * qr) / (sqi + sqj + sqk + sqr));
    ypr->roll = atan2(2.0 * (qj * qk + qi * qr), (-sqi - sqj + sqk + sqr));
    if (degrees) {
        ypr->yaw *= RAD_TO_DEG;
        ypr->pitch *= RAD_TO_DEG;
        ypr->roll *= RAD_TO_DEG;
    }
}

float Compass::getNorthDirection(float yaw) {
    if (yaw < 0) {
        return (360 + yaw);
    } else {
        return yaw;
    }
}

float Compass::ConvertToShownDirection(float AbsDir, int degree_shift) {
    return ((int(AbsDir) + degree_shift) % 360);
}

void Compass::quaternionToEulerRV(sh2_RotationVectorWAcc_t* rotational_vector,
                                  euler_t* ypr, 
                                  bool degrees) {
    quaternionToEuler(rotational_vector->real, rotational_vector->i, rotational_vector->j, rotational_vector->k, ypr, degrees);
}

void Compass::quaternionToEulerGI(sh2_GyroIntegratedRV_t* rotational_vector, 
                                  euler_t* ypr, 
                                  bool degrees) {
    quaternionToEuler(rotational_vector->real, rotational_vector->i, rotational_vector->j, rotational_vector->k, ypr, degrees);
}


void Compass::updateFromSensor(const sh2_SensorValue_t& value) {
    sensorValue_1 = value;
    update_sensor_1 = true;
}

float Compass::getHeading(BNO08x* imu, int degree_shift) {


    if (update_sensor_1) {
        if (reportType == SH2_ROTATION_VECTOR) {
            quaternionToEulerRV(&sensorValue_1.un.rotationVector, &ypr_1, true);
        } else if (reportType == SH2_GYRO_INTEGRATED_RV) {
            quaternionToEulerGI(&sensorValue_1.un.gyroIntegratedRV, &ypr_1, true);
        }
        update_sensor_1 = false;
    }

    float absDir = getNorthDirection(ypr_1.yaw);
    float shownDir = ConvertToShownDirection(absDir, degree_shift);
    return shownDir;
}

void Compass::setReports(BNO08x* imu, sh2_SensorId_t reportType, long report_interval)
{
    if (!imu->enableReport(reportType, report_interval))
    {
        Serial.println("Could not enable rotation vector on BNO08x");
    }
}


// Content from Compass.h

#ifndef COMPASS_H
#define COMPASS_H

#include <Arduino.h>
#include <Wire.h>
#include <sh2_SensorValue.h>
#include <SparkFun_BNO08x_Arduino_Library.h>

struct euler_t {
  float yaw;
  float pitch;
  float roll;
};

class Compass {
public:
    Compass() : update_sensor_1(false),
                reportType(SH2_ROTATION_VECTOR),
                reportIntervalUs(100000L) {}

    float getHeading(BNO08x* bno08x, int degree_shift);
    void updateFromSensor(const sh2_SensorValue_t& value);
    uint8_t getAccuracy() const { return sensorValue_1.status; }  // <-- ADD THIS
    long getReportInterval() const { return reportIntervalUs; }
    static void setReports(BNO08x* bno08x, sh2_SensorId_t reportType, long report_interval);

private:
    euler_t ypr_1;
    sh2_SensorValue_t sensorValue_1;
    bool update_sensor_1;
    sh2_SensorId_t reportType;
    long reportIntervalUs;

    static void quaternionToEuler(float qr, float qi, float qj, float qk, euler_t* ypr, bool degrees);
    static void quaternionToEulerRV(sh2_RotationVectorWAcc_t* rotational_vector, euler_t* ypr, bool degrees);
    static void quaternionToEulerGI(sh2_GyroIntegratedRV_t* rotational_vector, euler_t* ypr, bool degrees);


    
    float getNorthDirection(float yaw);
    float ConvertToShownDirection(float AbsDir, int degree_shift);
};

#endif // COMPASS_H




// Content from main.cpp
#include <Arduino.h>
#include "Compass.h"

#include <Wire.h>
#include <SparkFun_BNO08x_Arduino_Library.h>

#define BNO08X_RESET -1
#define TIMEOUT_BOOT_BNO 100
#define BNO08X_I2C_ADDRESS 0x4B


unsigned long millisOld;
const unsigned long vibrationDurationMillis = 200UL;
const unsigned long vibrationIntervalMillis = 1000UL;
const unsigned long serialKeepDurationMillis = 10UL * 1000UL;
const int PIN_SDA = A4;   // works on many cores; otherwise set explicit pin numbers
const int PIN_SCL = A5;

static uint32_t lastGoodEventMs = 0;
static uint32_t bootMs = 0;
static uint32_t lastRecoverAttemptMs = 0;

// Tune these:
const uint32_t STARTUP_GRACE_MS = 3000;          // wait after setup before any recovery
const uint32_t NO_EVENT_BEFORE_RECOVER_MS = 4000; // must be "dead" this long before recovery
const uint32_t RECOVER_COOLDOWN_MS = 5000;        // minimum time between recovery attempts


int degree_shift;
long lastSerialRecv = -10000L;
float lastSerialHeading = 0.0f;
Compass compass;
BNO08x imu;


static inline void wdtSync() {
  while (WDT->STATUS.bit.SYNCBUSY) { }
}

void initWatchdog_2s() {
  // Route 1kHz clock to WDT (required on SAMD21)
  GCLK->GENDIV.reg  = GCLK_GENDIV_ID(4) | GCLK_GENDIV_DIV(32); // 32kHz/32 = 1kHz
  GCLK->GENCTRL.reg = GCLK_GENCTRL_ID(4) |
                      GCLK_GENCTRL_SRC_OSCULP32K |
                      GCLK_GENCTRL_GENEN;
  while (GCLK->STATUS.bit.SYNCBUSY) { }

  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID_WDT |
                      GCLK_CLKCTRL_GEN_GCLK4 |
                      GCLK_CLKCTRL_CLKEN;
  while (GCLK->STATUS.bit.SYNCBUSY) { }

  // Disable WDT before config
  WDT->CTRL.reg = 0;
  wdtSync();

  // Set ~2s period (2048 cycles @ 1kHz)
  //  WDT->CONFIG.reg = WDT_CONFIG_PER(WDT_CONFIG_PER_2048);
  //  WDT->CONFIG.reg = WDT_CONFIG_PER(WDT_CONFIG_PER_2048_Val);
  WDT->CONFIG.reg = WDT_CONFIG_PER(0xB); // 2048 cycles is typically enum value 0xB on SAMD2  wdtSync();

  // Optional: early warning interrupt disabled
  WDT->EWCTRL.reg = 0;
  wdtSync();

  // Enable WDT
  WDT->CTRL.reg = WDT_CTRL_ENABLE;
  wdtSync();
}

static inline void feedWatchdog() {
  WDT->CLEAR.reg = WDT_CLEAR_CLEAR_KEY;
  wdtSync();
}


bool readBNO085() {
  // For SparkFun BNO08x library, a "read" is typically: imu.getSensorEvent()
  // Return true if we got a new event, false otherwise.
  return imu.getSensorEvent();
}

void initBNO085() {
  delay(1000);

  // Re-start the IMU and re-enable the report
  if (!imu.begin()) {
    Serial.println("BNO08x re-init failed");
    return;
  }
  Compass::setReports(&imu, SH2_ROTATION_VECTOR, compass.getReportInterval());
  Serial.println("BNO08x re-init OK");
}




bool i2cBusClear() {
  pinMode(PIN_SDA, INPUT_PULLUP);
  pinMode(PIN_SCL, INPUT_PULLUP);
  delayMicroseconds(5);

  // If SCL is stuck low, we can't clear it here
  if (digitalRead(PIN_SCL) == LOW) return false;

  // If SDA is stuck low, try to free it by clocking SCL
  if (digitalRead(PIN_SDA) == LOW) {
    pinMode(PIN_SCL, OUTPUT);
    for (int i = 0; i < 9; i++) {
      digitalWrite(PIN_SCL, HIGH);
      delayMicroseconds(5);
      digitalWrite(PIN_SCL, LOW);
      delayMicroseconds(5);
    }
    pinMode(PIN_SCL, INPUT_PULLUP);
    delayMicroseconds(5);
  }

  // Generate a STOP: SDA low -> SCL high -> SDA high
  pinMode(PIN_SDA, OUTPUT);
  digitalWrite(PIN_SDA, LOW);
  delayMicroseconds(5);

  pinMode(PIN_SCL, INPUT_PULLUP);
  delayMicroseconds(5);

  pinMode(PIN_SDA, INPUT_PULLUP);
  delayMicroseconds(5);

  return (digitalRead(PIN_SDA) == HIGH);
}


void reinitWire() {
  Wire.end();
  delay(10);
  Wire.begin();
  Wire.setClock(10000);
  Wire.setTimeout(50);
}


void sensorValueToDegree(int &degree_shift);

void setup() {
  delay(5000);
  Serial.begin(9600);

  unsigned long t0 = millis();
  while (millis() - t0 < 2000) {
    if (Serial) break;
    delay(10);
  }
  if (Serial) Serial.println("Serial monitor connected!");

  Wire.begin();
  Wire.setClock(10000);
  Wire.setTimeout(50);

  delay(200); // let BNO08x boot

  if (!imu.begin()) {
    Serial.println("BNO08x not detected!");
    while (1) { }
  }

  initWatchdog_2s();

  //Compass::setReports(&imu, SH2_ROTATION_VECTOR, compass.getReportInterval());
if (!imu.enableGameRotationVector(50)) {
  Serial.println("❌ enableGameRotationVector failed");
} else {
  Serial.println("✅ GameRotationVector enabled");
}
  
  
  Serial.println("Setup complete");

  bootMs = millis();
  lastGoodEventMs = millis();        // start "alive"
  lastRecoverAttemptMs = 0;
}

void loop() {
bool gotEvent = imu.getSensorEvent();

if (gotEvent) {
    Serial.print("✅ Event sensorId=");
    Serial.println(imu.sensorValue.sensorId);

    compass.updateFromSensor(imu.sensorValue);  // ← pass event
    lastGoodEventMs = millis();
} else {
    static uint32_t lastPrintMs = 0;
    if (millis() - lastPrintMs > 1000) {
        Serial.println("No sensor event (not necessarily an error)");
        lastPrintMs = millis();
    }
}

if (gotEvent) {
    float heading = compass.getHeading(nullptr, degree_shift);
    uint8_t acc = compass.getAccuracy();

    Serial.print("Heading: ");
    Serial.print(heading);
    Serial.print("  Accuracy: ");
    Serial.println(acc);
}

  // ✅ Do NOT attempt recovery during startup grace period
  if (millis() - bootMs < STARTUP_GRACE_MS) {
    feedWatchdog();
    return;
  }

  // ✅ Only recover if we've had no events for long enough
  bool deadTooLong = (millis() - lastGoodEventMs) > NO_EVENT_BEFORE_RECOVER_MS;

  // ✅ And don't try recovery too frequently
  bool cooldownOver = (lastRecoverAttemptMs == 0) ||
                      ((millis() - lastRecoverAttemptMs) > RECOVER_COOLDOWN_MS);

  if (deadTooLong && cooldownOver) {
    lastRecoverAttemptMs = millis();

    Serial.println("⚠️ No events for too long -> attempting recovery");

    i2cBusClear();
    reinitWire();

    delay(1000);     // <-- your requested "add some seconds"
    initBNO085();    // calls imu.begin() + setReports
  }

  feedWatchdog();
    float heading = compass.getHeading(&imu, degree_shift);
    uint8_t acc = compass.getAccuracy();

    Serial.print("Heading: ");
    Serial.print(heading);
    Serial.print("  Accuracy: ");
    Serial.println(acc);

}


